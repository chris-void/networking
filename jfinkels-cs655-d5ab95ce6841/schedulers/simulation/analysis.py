# analysis.py - tools for latency and throughput analysis for the simulation
#
# CS655 simulation assignment
# Jeffrey Finkelstein
# October 2011
"""Provides functions which facilitate the analysis required for latency and
throughput measurements in this simulation.

The throughput and packet latency can be computed from measurements stored by
the traffic source and sink. This module provides functions which compute the
throughput and latency between a specific source and sink. The
`PipelineStatistics` class encapsulates these computed statistics.

The SimPy package provides the `Tally` and `Monitor` classes, which observe
values over time during the simulation. We use one of these to measure the
latency of each packet as it is dequeued from the scheduler by the
`TrafficSink` (one tally or monitor for each source). These classes provide a
`mean()` function and a `var()` function, which provide the simple arithmetic
mean of the observed latencies and the sample variance of the observed
latencies, respectively.

"""
import numpy

STATS_FORMAT = \
"""source type: {0}
  measured throughput: {1} bps
  throughput difference: {2} bps
  throughput ratio: {3}
  mean latency: {4} seconds
  latency variance: {5} seconds"""
"""The format for the string representation of the `PipelineStatistics` object.

"""


class PipelineStatistics(object):
    """Provides observed statistics for the pipeline between a traffic source
    and a traffic sink.

    The statistics are accessible as attributes of this object. The available
    attributes include::

    * `source_type` - the type of the source (the result of calling the
      built-in `type()` function on the source)
    * `measured_throughput` - the measured throughput from the source to the
      sink in bits per second
    * `throughput_difference` - the difference between the expected throughput,
      which is the source's average rate of generation, and the measured
      throughput
    * `throughput_ratio` - the ratio of measured to expected throughput
    * `mean_latency` - the arithmetic mean of the latency (in seconds) of
      packets sent from the source to the sink
    * `latency_sample_variance` - the sampled variance of the latency of sent
      packets

    """

    def __init__(self, source, sink):
        """Sets attributes on this object representing the statistics observed
        for traffic on the pipeline between the specified traffic source and
        traffic sink.

        Pre-condition: the source and sink were in a simulation together which
        has already been run.

        """
        self.source_type = type(source)
        self.measured_throughput = measured_throughput(source, sink)
        self.throughput_difference = throughput_difference(source, sink)
        self.throughput_ratio = throughput_ratio(source, sink)
        self.mean_latency = mean_latency(source, sink)
        self.latency_sample_variance = latency_sample_variance(source, sink)

    def __str__(self):
        """Returns a string representation of the statistics."""
        return STATS_FORMAT.format(self.source_type,
                                   self.measured_throughput,
                                   self.throughput_difference,
                                   self.throughput_ratio,
                                   self.mean_latency,
                                   self.latency_sample_variance)


def measured_throughput(source, sink):
    """Returns the measured throughput, in bits per second, between the
    specified `source` and `sink`.

    Algorithm: if *b* is the number of bits generated by the specified source,
    *f* is the time of transmission of the final bit of the final packet of the
    specified source, and *a* is the time at which the first packet generated
    by the specified source arrives at the scheduler, then the measured
    throughput is *b / (f - a)*.

    Pre-condition: the `first_arrival_time` attribute of `source` is not
    `None`.

    Pre-condition: the `first_arrival_time` attribute of `source` does not
    equal the time of transmission of its final packet.

    Pre-condition: the source and sink were in a simulation together which has
    already been run.

    """
    b = source.bits_generated
    f = sink.time_of_last_transmission[source.source_id]
    a = source.first_arrival_time
    return b / float(f - a)


def throughput_ratio(source, sink):
    """Returns the ratio of measured throughput to expected throughput.

    Pre-condition: the source and sink were in a simulation together which has
    already been run.

    """
    return measured_throughput(source, sink) / source.generation_rate


def throughput_difference(source, sink):
    """Returns the difference, in bits per second, between the measured and
    expected throughput between the specified `source` and `sink`.

    A positive return value means that the measured throughput is greater than
    the expected throughput. A negative return value means that the measured
    throughput is less than the expected throughput.

    Pre-condition: the source and sink were in a simulation together which has
    already been run.

    """
    return measured_throughput(source, sink) - source.generation_rate


def queue_length_mean(monitor, time_weighted=False):
    """Returns the average of the queue lengths (in number of waiting packets)
    observed by the specified `monitor` (weighted by time if `time_weighted` is
    `True`).

    """
    if time_weighted:
        return monitor.timeAverage()
    else:
        return montior.mean()


def queue_length_variance(monitor, time_weighted=False):
    """Returns the sample variance of the queue lengths (in number of waiting
    packets) observed by the specified `monitor` (weighted by time if
    `time_weighted` is `True`).

    """
    if time_weighted:
        return monitor.timeVariance()
    else:
        return monitor.var()


def mean_latency(source, sink):
    """Returns the mean latency for packets from the specified traffic source
    to the specified traffic sink.

    Ignores the first ten percent and the last five percent of the latency
    values.

    Pre-condition: the source and sink were in a simulation together which has
    already been run.

    """
    data = sink.latency_monitors[source.source_id].yseries()
    length = len(data)
    transient_left = int(0.1 * length)
    transient_right = int(0.05 * length)
    if transient_right == 0:
        trimmed = data[transient_left:]
    else:
        trimmed = data[transient_left:-transient_right]
    return numpy.mean(trimmed)


def latency_sample_variance(source, sink):
    """Returns the sample variance for packet latency from the specified
    traffic source to the specified traffic sink.

    Ignores the first ten percent and the last five percent of the latency
    values.

    Pre-condition: the source and sink were in a simulation together which has
    already been run.

    """
    data = sink.latency_monitors[source.source_id].yseries()
    length = len(data)
    transient_left = int(0.1 * length)
    transient_right = int(0.05 * length)
    if transient_right == 0:
        trimmed = data[transient_left:]
    else:
        trimmed = data[transient_left:-transient_right]
    return numpy.var(trimmed)
