# test_endpoints.py - unit tests for the endpoints module
#
# CS655 simulation assignment
# Jeffrey Finkelstein
# October 2011
"""Unit tests for the endpoints module."""
from unittest import skip
from unittest import TestCase

from SimPy.Simulation import hold
from SimPy.Simulation import infinity
from SimPy.Simulation import Process
from SimPy.Simulation import Simulation

from simulation.endpoints import TrafficManager
from simulation.endpoints import TrafficSink
from simulation.endpoints import TrafficSource
from simulation.schedulers import FIFO
from simulation.schedulers import Item

__all__ = ['TrafficSinkTest', 'TrafficSourceTest']


class SinglePacketTrafficSource(Process):
    """A traffic source which generates a single packet of length 100."""
    def __init__(self, scheduler, *args, **kw):
        """Initializes this traffic source with access to the specified
        `scheduler` for enqueuing its single packet.

        Passes on the positional and keyword arguments to the constructor of
        the superclass.

        """
        super(SinglePacketTrafficSource, self).__init__(*args, **kw)
        self.scheduler = scheduler

    def ACTIONS(self):
        """Immediately enqueues an item of length 100 on the scheduler
        specified in the constructor of this class.

        """
        yield hold, self, 0
        self.scheduler.enqueue(Item(0, 100))


class TrafficSourceTest(TestCase):
    """Test for the TrafficSource class."""
    def setUp(self):
        """Creates the simulation and traffic source to test."""
        self.sim = Simulation()
        self.scheduler = FIFO()
        self.manager = TrafficManager(max_packets=10)
        self.source = TrafficSource(self.scheduler, 0, 100, 1, self.manager,
                                    sim=self.sim)
        self.sim.initialize()

    def test_ACTIONS(self):
        """Tests that the traffic source functions correctly as a SimPy
        `Process`, generating the maximum number of packets as specified by its
        manager.

        """
        self.source.start()
        self.sim.simulate(until=infinity)
        self.assertEqual(self.manager.max_packets, len(self.scheduler))
        # source generates data at 1 bit per second
        expected_time = sum(item.length for item in self.scheduler.queue)
        # the implementation of the traffic source generates *but does not
        # enqueue* one final item, so we have to wait for that final item to be
        # generated before the simulation steps; therefore, we don't know
        # exactly when the simulation ends, just that it is after expected_time
        self.assertGreaterEqual(self.sim.now(), expected_time)

    def test_correct_number_enqueued_one_source(self):
        """Tests that a single source generates exactly the maximum number of
        items to enqueue as specified by its manager.

        """
        self.source.start()
        self.sim.simulate(until=infinity)
        self.assertEqual(self.manager.max_packets, len(self.scheduler))

        self.manager.max_packets = 100
        self.sim = Simulation()
        self.source = TrafficSource(self.scheduler, 0, 100, 1, self.manager,
                                    sim=self.sim)
        self.sim.initialize()
        self.source.start()
        self.sim.simulate(until=infinity)
        self.assertEqual(self.manager.max_packets, len(self.scheduler))
        self.assertEqual(self.manager.num_packets_generated, 100)

    def test_correct_number_enqueued_multiple_sources(self):
        """Tests that multiple traffic sources generates exactly the maximum
        number of packets to enqueue overall, as specified by their manager.

        """
        self.sim = Simulation()
        self.sim.initialize()
        self.manager.max_packets = 50
        for n in range(10):
            TrafficSource(self.scheduler, n, 100, 1, self.manager,
                          sim=self.sim).start()
        self.sim.simulate(until=infinity)
        self.assertEqual(50, len(self.scheduler))

    def test_first_arrival_time(self):
        """Tests that the `first_arrival_time` attribute of that
        `TrafficSource` class correctly marks the time of the first arrival of
        a packet generated by that source on the scheduler's queue.

        """
        self.assertIsNone(self.source.first_arrival_time)
        self.source.start()
        self.sim.simulate(until=infinity)
        self.assertLess(self.source.first_arrival_time, self.sim.now())

class TrafficSinkTest(TestCase):
    """Test for the TrafficSink class."""
    def setUp(self):
        """Creates the simulation and traffic sink to test."""
        self.sim = Simulation()
        self.scheduler = FIFO()
        self.manager = TrafficManager()
        self.manager.max_packets = 1
        self.sink = TrafficSink(self.scheduler, self.manager, sim=self.sim)
        self.sim.initialize()

    def test_dequeue_nonempty(self):
        """Tests that the traffic sink dequeues packets from the scheduler at
        the correct rate, when it is nonempty.

        """
        # enqueue packets of length 1, 2, ..., 10
        for n in range(1, 11):
            self.scheduler.enqueue(Item(n, n))
        self.sink.start()
        self.sim.simulate(until=infinity)
        self.assertEqual(0, len(self.scheduler))
        # 1 + 2 + ... + 10 = 55, total length in bits of all packets, processed
        # at 1 bit per second
        self.assertEqual(55, self.sim.now())

    def test_dequeue_empty(self):
        """Tests that the traffic sink waits for the queue to have a packet,
        then dequeues it.

        """
        source = SinglePacketTrafficSource(self.scheduler, sim=self.sim)
        source.start(at=10)
        # sink should wait until 10 before dequeueing
        self.sink.start()
        self.sim.simulate(until=infinity)
        self.assertEqual(110, self.sim.now())

    def test_correct_number_dequeued(self):
        """Tests that the same number of items enqueued are also dequeued."""
        self.manager.max_packets = 100
        source = TrafficSource(self.scheduler, 0, 100, 1, self.manager,
                               sim=self.sim)
        source.start()
        self.sink.start()
        self.sim.simulate(until=infinity)
        self.assertEqual(self.manager.num_packets_generated,
                         len(self.sink.dequeued_items))
        self.assertEqual(self.manager.num_packets_generated,
                         self.manager.max_packets)

    def test_time_of_last_transmission(self):
        """Tests that the time of last transmission of packets is correct."""
        self.scheduler.enqueue(Item(0, 100))
        self.scheduler.enqueue(Item(1, 100))
        self.scheduler.enqueue(Item(0, 200))
        self.sink.start()
        self.sim.simulate(until=infinity)
        self.assertEqual(self.sink.time_of_last_transmission[0], 400)
        self.assertEqual(self.sink.time_of_last_transmission[1], 200)
